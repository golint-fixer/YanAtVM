import time
import threading
import urllib
import urllib2
import re
import subprocess
import sys
import logging
import logging.config
import Queue
import os
import socket
import abc
import tempfile

from pyVim import connect
from pyVmomi import vim
from pyVmomi import vmodl
import atexit
import requests
from PySTAF import *

from tools import pchelper

import zipfile
from os.path import isdir, join, normpath, split
# import MySQLdb
from multiprocessing import Process, Queue

sys.setrecursionlimit(10000)

logger = logging.getLogger(__name__)
BUILD_TAG = os.environ.get('BUILD_TAG', 'BATs')

logging.config.dictConfig({
    'version': 1,
    'disable_existing_loggers': False,  # this fixes the problem

    'formatters': {
        'standard': {
            'format': '%(asctime)-15s (%(processName)-9s) %(message)s'
        },
    },
    'handlers': {
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'standard'
        },
        'file': {
            'class': 'logging.handlers.RotatingFileHandler',
            'level': 'INFO',
            'filename': 'c:/BATs/logs/%s.log' % BUILD_TAG,
            'formatter': 'standard',
            'maxBytes': 10485760,
            'encoding': "utf8"
        }
    },
    'loggers': {
        '': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': True
        }
    }
})

try:
    import simplejson as json
except ImportError:
    import json


def get_pattern_product(product, system_arch):
    """


    :param product: client, agent, broker, viewtest, viewapioperator
    :param system_arch: x86, x64
    :rtype : String, product name pattern.
    """
    arch = ''
    if product == ProductEnum.VIEWAGENT or product == ProductEnum.VIEWBROKER:
        arch = '-x86_64-' if system_arch.endswith('64') else '-'
    if product == ProductEnum.VIEWCLIENT:
        arch = 'x86_64' if system_arch.endswith('64') else 'x86'

    return {
        'viewtest': r'VMware-viewtest-\w.\w.\w-\d+\.zip',
        'viewapioperator': r'VMware-viewapioperator-\w.\w.\w-\d+\.zip',
        'client': r'VMware-Horizon-View-Client-%s-\d+\.\d+\.\d+\-\d+\.exe' % arch,
        'agent': r'VMware-viewagent%s\w.\w.\w-\d+\.exe' % arch,
        'broker': r'VMware-viewconnectionserver%s\w.\w.\w-\d+\.exe' % arch
    }.get(product, None)


class ProductEnum():
    VIEWCLIENT = 'client'
    VIEWAGENT = 'agent'
    VIEWBROKER = 'broker'
    VIEWTEST = 'viewtest'
    VIEWAPIOPERATOR = 'viewapioperator'


class BuildWebProduct:
    def __init__(self):
        pass

    #  previous is viewcrt
    VIEWCLIENT = 'viewclientwin'
    VIEWAGENT = 'view'
    VIEWBROKER = 'view'


class VC_cred():
    user = 'administrator'
    pwd = '******'


class Domain_cred():
    user = 'hovdi\\administrator'
    pwd = '******'


class DownloadError(Exception):
    """
    Error for the build download.
    """

    def __init__(self, *args, **kwargs):  # real signature unknown
        pass

    @staticmethod  # known case of __new__
    def __new__(S, *more):  # real signature unknown; restored from __doc__
        """ T.__new__(S, ...) -> a new object with type S, a subtype of T """
        pass


class AgentInstallException(Exception):
    def __init__(self, *args, **kwargs):  # real signature unknown
        Exception.__init__(self, *args, **kwargs)


# os.environ.__setitem__('components', 'RDSH')
# os.environ.__setitem__('selectBATEnv', 'BAT5-W764')
# os.environ.__setitem__('brokerBranch', 'view-server-main')
# os.environ.__setitem__('agentBranch', 'view-server-main')
# os.environ.__setitem__('viewBuildType', 'ob')
# os.environ.__setitem__('brokerBuildNo', '')
# os.environ.__setitem__('agentBuildNo', '')
# os.environ.__setitem__('BUILD_TAG', '5')
# os.environ.__setitem__('client', '5-10.112.118.252')
# os.environ.__setitem__('clientImage', '5-Win81U3x64P')
# os.environ.__setitem__('clientBranch', 'crt-main')
# os.environ.__setitem__('clientBuildNum', '')
# os.environ.__setitem__('clientBuildType', 'ob')
# os.environ.__setitem__('testSuite', '')
# os.environ.__setitem__('executeParams', '')


class Parameters(object):
    def __init__(self):
        components = os.environ.get('components', '')
        select_bat_env = os.environ.get('selectBATEnv', '')
        broker_branch = os.environ.get('brokerBranch', '')
        agent_branch = os.environ.get('agentBranch', '')
        view_build_type = os.environ.get('viewBuildType', '')
        broker_build_no = os.environ.get('brokerBuildNo', '')
        agent_build_no = os.environ.get('agentBuildNo', '')

        # These are variables generated by Jenkins
        build_tag = os.environ.get('BUILD_TAG', '')

        # For enable FIPS
        enable_fips_str = os.environ.get('enableFIPS', '')
        if enable_fips_str == 'true':
            enable_fips = True
        else:
            enable_fips = False

        # These parameters ar for client.
        client = os.environ.get('client', '')
        client_image = os.environ.get('clientImage', 'NULL')
        client_branch = os.environ.get('clientBranch', '')
        client_build_num = os.environ.get('clientBuildNum', '')
        client_build_type = os.environ.get('clientBuildType', '')
        test_suite = os.environ.get('testSuite', '')
        execute_params = os.environ.get('executeParams', '')
        # These parameters ar for client.

        self.components = components
        self.broker_branch = broker_branch
        self.agent_branch = agent_branch
        self.view_build_type = view_build_type
        self.broker_build_no = broker_build_no
        self.agent_build_no = agent_build_no
        self.build_tag = build_tag
        self.select_bat_env = select_bat_env

        (self.bat_env_no, self.pool_name) = Parameters.get_bat_env_pool_name(select_bat_env)

        self.client = client
        self.client_image = client_image[2:]
        self.client_branch = client_branch
        self.client_build_num = client_build_num
        self.client_build_type = client_build_type
        self.test_suite = test_suite
        self.execute_params = execute_params
        self.enable_fips = enable_fips

        self.client_build_path_64 = ''
        self.client_build_path_32 = ''
        self.agent_build_path = ''
        self.broker_build_path = ''
        self.rdsh_build_path = ''
        self.view_test_build_path = ''
        self.view_api_operator_build_path = ''

    @staticmethod
    def get_bat_env_pool_name(select_bat_env):
        assert (select_bat_env != '')
        select_bat_env = select_bat_env[3:]
        env_temp = select_bat_env.split('-')
        bat_env_no = env_temp[0]
        pool_name = 'NR-' + env_temp[1]
        assert (bat_env_no != '')
        return bat_env_no, pool_name


class BATsEnvParameters(object):
    def __init__(self, parameters):
        self.parameters = parameters
        self.skip_broker = False
        self.skip_client = False
        self.skip_agent = False
        self.skip_rdsh = False
        self.agent_config = False
        self.run_tc = True
        self.legacy_agent = False
        self.vc_server = ''
        self.broker_ip = ''
        self.broker_vm = ''
        self.rds_vm = ''
        self.rds_hostname = ''
        self.agent_vm = ''
        self.agent_arch = ''
        self.client_ip = ''
        self.client_arch = ''

        if parameters.bat_env_no == "1":
            self.vc_server = '10.117.46.226'
            self.broker_ip = '10.117.45.62'
            self.broker_vm = 'wuy-broker'
            self.rds_vm = 'w2012-RDSH-wuy'
            self.rds_hostname = 'w2012-RDSH-wuy.hovdi.qa'
            self.client_ip = '10.112.118.183'
            if parameters.pool_name == 'NR-W786':
                self.agent_vm = 'win7x86-bats1'
                self.agent_arch = 'x86'
            elif parameters.pool_name == 'NR-Vista':
                self.agent_vm = 'WINDOWS-RTTNFD6'
                self.agent_arch = 'x86'
            elif parameters.pool_name == 'NR-W864':
                self.agent_vm = 'MICROSO-7EDVR8V'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W2012':
                self.agent_vm = 'Win2012-R2-Datacenter'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W764':
                self.agent_vm = 'win7x64-bats1'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W1064':
                self.agent_vm = 'win10x64-bats1'
                self.agent_arch = 'x64'
            else:
                logger.info("Pool name provided is invalid, there's no such agent existing")

        if parameters.bat_env_no == "2":
            self.vc_server = '10.117.45.56'
            self.broker_ip = '10.117.46.130'
            self.broker_vm = 'JD-2k8-521'
            self.rds_vm = 'BATs-RDSH-A1'
            self.rds_hostname = 'BATs-RDSH-A1.hovdi.qa'
            self.client_ip = '10.112.118.184'
            if parameters.pool_name == 'NR-XP':
                self.agent_vm = 'BATs-XP-Pro'
                self.agent_arch = 'x86'
            elif parameters.pool_name == 'NR-W8164':
                self.agent_vm = 'BATs-W81-A1'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W764':
                self.agent_vm = 'BATs-W764-A1'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W786':
                self.agent_vm = 'BATs-W7ESP1-A1'
                self.agent_arch = 'x86'
            else:
                logger.info("Pool name provided is invalid, there's no such agent existing")

        if parameters.bat_env_no == "3":
            self.vc_server = '10.117.46.216'
            self.broker_ip = '10.117.46.189'
            self.broker_vm = 'pascadia-broker'
            self.rds_vm = 'win2012-RDSH'
            self.rds_hostname = 'win2012-jack.hovdi.qa'
            self.client_ip = '10.112.118.185'
            if parameters.pool_name == 'NR-W81U2':
                self.agent_vm = 'A_BATSW81U264-Ent'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W764':
                self.agent_vm = 'A-BATSW764'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W2012':
                self.agent_vm = 'Win2012-R2-Datacenter'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-Vista':
                self.agent_vm = 'vista-sp2-x86'
                self.agent_arch = 'x86'
            else:
                logger.info("Pool name provided is invalid, there's no such agent existing")

        if parameters.bat_env_no == "4":
            self.vc_server = '10.117.46.29'
            self.broker_ip = '10.117.46.27'
            self.broker_vm = 'Auto-2k8-BR'
            self.rds_vm = 'Auto-2k8-A2'
            self.rds_hostname = 'Auto-2k8-A2.hovdi.qa'
            self.client_ip = '10.112.118.251'
            if parameters.pool_name == 'NR-Vista':
                self.agent_vm = 'Auto-VistaBus'
                self.agent_arch = 'x86'
            elif parameters.pool_name == 'NR-W732':
                self.agent_vm = 'Auto-W7SP1x32'
                self.agent_arch = 'x86'
            elif parameters.pool_name == 'NR-W764':
                self.agent_vm = 'Auto-W7SP1x64'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W864':
                self.agent_vm = 'Auto-W8x64'
                self.agent_arch = 'x64'
            else:
                logger.info("Pool name provided is invalid, there's no such agent existing")

        if parameters.bat_env_no == "5":
            self.vc_server = '10.117.46.226'
            self.broker_ip = '10.117.46.21'
            self.broker_vm = 'JD-2k8-BR-Pocono'
            self.rds_vm = 'JD-2k8-RDSH'
            self.rds_hostname = 'JD-2k8-RDSH.hovdi.qa'
            self.client_ip = '10.112.118.252'
            if parameters.pool_name == 'NR-Vista':
                self.agent_vm = 'JD-VB-MP'
                self.agent_arch = 'x86'
            elif parameters.pool_name == 'NR-W732':
                self.agent_vm = 'JD-W7-MP'
                self.agent_arch = 'x86'
            elif parameters.pool_name == 'NR-W764':
                self.agent_vm = 'JD-W764-FP'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W864':
                self.agent_vm = 'JD-W8-MP'
                self.agent_arch = 'x64'
            else:
                logger.info("Pool name provided is invalid, there's no such agent existing")

        if parameters.bat_env_no == "6":
            self.vc_server = '10.117.46.226'
            self.broker_ip = '10.117.46.160'
            self.broker_vm = 'BrokerWin2k12'
            self.rds_vm = 'JD-2k8-RDSH'
            self.rds_hostname = 'JD-2k8-RDSH.hovdi.qa'
            self.client_ip = '10.112.118.252'
            if parameters.pool_name == 'NR-Vista':
                self.agent_vm = 'JD-VB-MP'
                self.agent_arch = 'x86'
            elif parameters.pool_name == 'NR-W732':
                self.agent_vm = 'JD-W7-MP'
                self.agent_arch = 'x86'
            elif parameters.pool_name == 'NR-W764':
                self.agent_vm = 'Auto-Win7-64'
                self.agent_arch = 'x64'
            elif parameters.pool_name == 'NR-W864':
                self.agent_vm = 'JD-W8-MP'
                self.agent_arch = 'x64'
            else:
                logger.info("Pool name provided is invalid, there's no such agent existing")

        ''' Install broker should force refresh agent. '''
        if parameters.components.lower().find('broker') < 0 or self.broker_vm == '':
            self.skip_broker = True
        if parameters.components.lower().find('agent') < 0 or self.agent_vm == '':
            self.skip_agent = True
        if parameters.components.lower().find('rdsh') < 0 or self.rds_vm == '':
            self.skip_rdsh = True
        if parameters.components.lower().find('client') < 0 or parameters.client == '':
            self.skip_client = True
        if parameters.components.lower().find('conf') >= 0 or not self.skip_broker:
            self.agent_config = True
        ''' It's just for debugging back ground environment installation. '''
        if parameters.components.lower().find('norun') >= 0:
            self.run_tc = False
        # Do not rebuild XP/Vista agents, they are pre-prepared with 601/602 agent build
        if parameters.pool_name.lower().find('xp') > 0 or parameters.pool_name.lower().find('vista') > 0:
            self.legacy_agent = True

        self.do_prepare_setting()

        logger.info("-" * 70)
        logger.info("Skip Broker :                {0}".format(str(self.skip_broker)))
        logger.info("Skip Agent :                 {0}".format(str(self.skip_agent)))
        logger.info("Skip RDSH :                  {0}".format(str(self.skip_rdsh)))
        logger.info("Skip Client :                {0}".format(str(self.skip_client)))
        logger.info("Agent Configuration :        {0}".format(str(self.agent_config)))
        logger.info("Run Test Cases :             {0}".format(str(self.run_tc)))
        logger.info("Select Env :                 {0}".format(str(parameters.bat_env_no)))
        logger.info("VC :                         {0}".format(str(self.vc_server)))
        logger.info("Agent VM :                   {0}".format(str(self.agent_vm)))
        logger.info("Broker VM :                  {0}".format(str(self.broker_vm)))
        logger.info("Broker IP :                  {0}".format(str(self.broker_ip)))
        logger.info("-" * 70)

    def do_prepare_setting(self):
        """
            This function will get the build num and download build for later use.

            If choose the web commander to install build, just ignore the download part which only serves
            for the install that implemented by myself.

            As i use the multiple threads to install build, so download firstly with the signle thread mode.

            For the RDSH build, as it only to be installed on the 64 based platform, so if the agent is 32 bit, here
            have to force download a 64 bit version as the RDSH installer.

        """
        build_web = BuildWeb()

        if not self.skip_agent:
            if self.parameters.agent_build_no == '' or not self.parameters.agent_build_no.isdigit():
                self.parameters.agent_build_no = BuildWeb.get_latest_recommend_build(BuildWebProduct.VIEWAGENT,
                                                                                     self.parameters.agent_branch,
                                                                                     self.parameters.view_build_type)
            assert (self.parameters.agent_build_no != ''), "Agent should not be null."
            logger.info("Agent build number: " + str(self.parameters.agent_build_no))
            self.parameters.agent_build_path = build_web.download_by_build_num(self.parameters.agent_build_no,
                                                                               ProductEnum.VIEWAGENT, self.agent_arch)
            logger.info("Agent build path: " + str(self.parameters.agent_build_path))

        if not self.skip_broker:
            if self.parameters.broker_build_no == '' or not self.parameters.broker_build_no.isdigit():
                self.parameters.broker_build_no = BuildWeb.get_latest_recommend_build(BuildWebProduct.VIEWBROKER,
                                                                                      self.parameters.broker_branch,
                                                                                      self.parameters.view_build_type)
            assert (self.parameters.broker_build_no != ''), "Broker should not be null."
            logger.info("Broker build number: " + str(self.parameters.broker_build_no))
            ''' Broker only support 64 bit platform '''
            self.parameters.broker_build_path = build_web.download_by_build_num(self.parameters.broker_build_no,
                                                                                ProductEnum.VIEWBROKER, 'x64')
            logger.info("Broker build path: " + str(self.parameters.broker_build_path))
            self.parameters.view_test_build_path = build_web.download_by_build_num(self.parameters.broker_build_no,
                                                                                   ProductEnum.VIEWTEST, '')
            logger.info("View Test build path: " + str(self.parameters.view_test_build_path))
            self.parameters.view_api_operator_build_path = build_web.download_by_build_num(
                self.parameters.broker_build_no,
                ProductEnum.VIEWAPIOPERATOR, '')
            logger.info("View API Operator build path: " + str(self.parameters.view_api_operator_build_path))

        if not self.skip_rdsh:
            if not self.skip_agent:
                ''' RDSH only supports 64 bit. '''
                if self.agent_arch != 'x64':
                    self.parameters.rdsh_build_path = build_web.download_by_build_num(self.parameters.agent_build_no,
                                                                                      ProductEnum.VIEWAGENT, 'x64')
                else:
                    self.parameters.rdsh_build_path = self.parameters.agent_build_path
            else:
                self.parameters.agent_build_no = BuildWeb.get_latest_recommend_build(BuildWebProduct.VIEWAGENT,
                                                                                     self.parameters.agent_branch,
                                                                                     self.parameters.view_build_type)
                self.parameters.rdsh_build_path = build_web.download_by_build_num(self.parameters.agent_build_no,
                                                                                  ProductEnum.VIEWAGENT, 'x64')
            logger.info("RDSH build path: " + str(self.parameters.rdsh_build_path))

        ''' Here is just download both 64 and 32 for further use. '''
        if self.parameters.client_build_num == '' or not self.parameters.client_build_num.isdigit():
            self.parameters.client_build_num = BuildWeb.get_latest_build(BuildWebProduct.VIEWCLIENT,
                                                                         self.parameters.client_branch,
                                                                         self.parameters.view_build_type)
            assert (self.parameters.client_build_num != ''), "Client should not be null."
            logger.info("Client build number: " + str(self.parameters.client_build_num))

        if not self.skip_client:
            ''' Get the latest client build... '''

            self.parameters.client_build_path_64 = build_web.download_by_build_num(self.parameters.client_build_num,
                                                                                   ProductEnum.VIEWCLIENT, '64')
            self.parameters.client_build_path_32 = build_web.download_by_build_num(self.parameters.client_build_num,
                                                                                   ProductEnum.VIEWCLIENT, '32')

            logger.info("Client build path 64: " + str(self.parameters.client_build_path_64))
            logger.info("Client build path 32:" + str(self.parameters.client_build_path_32))


class BuildWeb:
    """Interact with build web."""

    def __init__(self):
        self.delimiter = '#' * 80
        self.lineSep = '\r\n'

    @staticmethod
    def get_resource_list(url):
        """Get build info data"""
        build_web = 'http://buildapi.eng.vmware.com'
        url = '%s%s' % (build_web, url)
        """print 'Fetching %s ...\r\n' % url"""
        ret = urllib2.urlopen(url)
        status = int(ret.code)
        if status != 200:
            logging.error('HTTP status %d', status)
            raise Exception('Error: %s' % data['http_response_code']['message'])
        content = ret.read()
        if json:
            data = json.loads(content)
        else:
            data_dict = {}
            data_list = []
            for i in content.replace(' ', '').split('[{')[1].split('}]')[0].split('},{'):
                for j in i.split(','):
                    data_dict[j.split(':')[0].strip().strip('"')] = j.split(':')[1].strip().strip('"')
                data_list.append(data_dict)
                data_dict = {}
            data_dict['_list'] = data_list
            data = data_dict
        return data

    @staticmethod
    def get_latest_recommend_build(product, branch, build_type='ob'):
        ret = ''
        url = '/%s/build/?' \
              'product=%s&' \
              'branch=%s&' \
              '_limit=%d&' \
              '_order_by=-id&' \
              'buildstate__in=succeeded,storing&' \
              'buildtype__in=release,beta' \
              % (build_type, product, branch, 100)
        data = BuildWeb.get_resource_list(url)
        found_recommend = 0

        for item in data['_list']:
            build_id = item['id']
            """Save the latest build if there's no "recommended" build"""
            if ret == '': ret = str(build_id)
            qa_rrl = '/%s/qatestresult/?build=%s' % (build_type, build_id)
            qa_data = BuildWeb.get_resource_list(qa_rrl)
            for result in qa_data['_list']:
                if result['qaresult'] == "recommended":
                    ret = str(build_id)
                    found_recommend = 1
            if found_recommend == 1:
                break
        return ret

    @staticmethod
    def get_latest_build(product, branch, build_type='ob'):
        url = '/%s/build/?' \
              'product=%s&' \
              'branch=%s&' \
              '_limit=%d&' \
              '_order_by=-id&' \
              'buildstate__in=succeeded,storing&' \
              'buildtype__in=release,beta' \
              % (build_type, product, branch, 1)
        """print 'url is %s' % url"""
        data = BuildWeb.get_resource_list(url)
        return data['_list'][0]['id']

    @staticmethod
    def get_deliverable_list_by_build_id(build_id, build_type='ob'):
        url = '/%s/deliverable/?build=%s' % (build_type, build_id)
        data = BuildWeb.get_resource_list(url)
        if data is not None:
            return data['_list']
        return None

    @staticmethod
    def get_version_by_build_num(build_id, build_type='ob'):
        url = '/%s/build/%s' % (build_type, build_id)
        data = BuildWeb.get_resource_list(url)
        if data is not None:
            return data['version']
        return None

    def download_by_build_num(self, build_id, product, system_arch, retry=True):

        """


        :param build_id:
        :param product:
        :param system_arch: x86 or x64 -- this is a predefined agent vm arch, as this script will not communicate with
                                          the vm machine. Thus, just hard code before run.
        :param retry:

       :rtype : str, build local path. Should be in the temp folder.
       """
        builds = BuildWeb.get_deliverable_list_by_build_id(build_id)
        target_path = None
        target_pattern = get_pattern_product(product, system_arch)
        assert (builds != '')
        assert (target_pattern != '')

        for build in builds:
            matched = re.search(target_pattern, build['path'])
            if matched:
                target_path = build['_download_url']
                break

        """download build to temp folder."""
        try:
            local_file_path = os.path.join(tempfile.gettempdir(), os.path.basename(target_path))
            # logger.info('Downloading... : ' + str(build_id))
            if not os.path.exists(local_file_path):
                urllib.urlretrieve(target_path, local_file_path)
            logger.info('the build was downloaded successfully on the local : ' + local_file_path)
        except Exception, e:
            logger.info(e)
            if not retry:
                raise DownloadError("Build ID " + str(build_id) + " download error.")
            """will retry one more to handle any exception"""
            logger.info('Get download exception, will try one more time and stop the workflow if meet it twice.')
            self.download_by_build_num(build_id, product, system_arch, False)

        return local_file_path


class WebCommander:
    def __init__(self):
        pass

    def request_web_commander(self, url, action, redo=1):
        return_code = ''
        try:
            """by default redo one times if failed. But since we deal with installView case separately,
              disable redo for the function."""
            logger.info('action %s : %s ' % (action, url))
            ret = urllib2.urlopen(url)
            if ret.getcode() != 200:
                logger.info('http return code: %s != 200' % ret.getcode())
                return '9999'
            resp = ret.read()
            if resp.find('<returnCode>') > 0:
                return_code = resp.split(r'</returnCode>')[0].split('<returnCode>')[1]
            else:
                if url.find('brokerRemovePool') == -1:
                    logger.info(resp)
                """sometimes web commander may run into error and return nonsense (html source of the main page)"""
                return_code = '9999'

            if return_code != '4488':  # get the real exit code of view installation
                if url.find('brokerRemovePool') == -1:
                    logger.info(resp)
                if resp.find('Exit code:') > 0:
                    return_code = resp.split(r'</fullyQualifiedErrorId>')[0].split('Exit code:')[1]
                elif resp.find('VMware Tools is not running') > 0:
                    return_code = '4007'
                    logger.info('***** webCommander action: ' + action
                                + ' return code: ' + return_code + '. Failed. *****\n')
                """redo by calling itself recursively"""
                if redo > 0:
                    return_code = self.request_web_commander(url, action, redo - 1)
            else:
                logger.info('***** webCommander action: ' + action + ' return code: '
                            + return_code + '. Succeeded. *****\n')
        except Exception, e:
            logger.info(e)
        finally:
            return return_code

    """The return code of this function will also be used to check VC's connectivity"""

    def revert_snapshot(self, vc_server, vm_name, snapshot_name='NRready'):
        assert (vm_name != '')
        url_revert = 'http://10.136.240.188/webcmd.php?command=snapshotAction&serverAddress=%s&' \
                     'serverUser=administrator&serverPassword=&vmName=%s&ssName=%s&ssDescription=&action=restore' \
                     % (vc_server, vm_name, snapshot_name)
        url_power_on = 'http://10.136.240.188/webcmd.php?command=vmPowerOn&serverAddress=%s&' \
                       'serverUser=administrator&vmName=%s' % (vc_server, vm_name)
        return_code = self.request_web_commander(url_revert, 'revert snapshot')
        if return_code == '4488':
            self.request_web_commander(url_power_on, 'Power On')
        return return_code

    def vm_trust(self, vc_server, vm_name):
        url_trust_cert = 'http://10.136.240.188/webcmd.php?command=vmTrustVMwareSignature' + \
                         '&serverAddress=%s&serverUser=administrator&vmName=%s&guestUser=HOVDI%sAdministrator' \
                         % (vc_server, vm_name, r'%5C')
        return self.request_web_commander(url_trust_cert, 'vmTrustVMwareSignature')

    def update_vm_tools(self, vc_server, vm_name):
        update_vm_tools = 'http://10.136.240.188/webcmd.php?command=vmUpdateTools&serverAddress=%s&' \
                          'serverUser=administrator&vmName=%s' % (vc_server, vm_name)
        self.request_web_commander(update_vm_tools, 'vmUpdateTools')

    def restart_vm(self, vc_server, vm_name):
        url_restart = 'http://10.136.240.188/webcmd.php?command=vmRestart&serverAddress=%s&' \
                      'serverUser=administrator&vmName=%s' % (vc_server, vm_name)
        return_code = self.request_web_commander(url_restart, 'vmRestart', 0)
        if return_code != '4488':
            if return_code == '4007':
                self.update_vm_tools(vm_name)
                time.sleep(180)
            self.request_web_commander(url_restart, 'vmRestart', 0)

    def power_off_on_vm(self, vc_server, vm_name):
        """

       :param vc_server:
       :param vm_name:

        it's a workaround for restart vm machine.

       """
        url_shutdown = 'http://10.136.240.188/webcmd.php?command=vmShutdown&serverAddress=%s&' \
                       'serverUser=administrator&vmName=%s' % (vc_server, vm_name)
        url_power_on = 'http://10.136.240.188/webcmd.php?command=vmPowerOn&serverAddress=%s&' \
                       'serverUser=administrator&vmName=%s' % (vc_server, vm_name)
        self.request_web_commander(url_shutdown, 'vmShutdown')
        time.sleep(600)  # Wait 10 minutes for View to reconfigure the VM, mostly for increasing the video vRAM.
        self.request_web_commander(url_power_on, 'vmPowerOn')

    def install_prepare(self, vc_server, vm_name):
        assert (vm_name != '')

        """
           The first step is to revert the VM.
           if this step returns "vc is not reachable" error, then exit and fail the Jenkins build.

        """
        if self.revert_snapshot(vc_server, vm_name) == '4001':
            logger.info("Connecting to the VC is failed, the build is cancelled" % vc_server)
            sys.exit(-1)

        """
           wait for enough long time since some VMs are a bit slow,
           win10 sometimes cannot be launched success in 5 minutes, increase it to 500 seconds.

        """
        time.sleep(600)

        assert self.vm_trust(vc_server, vm_name) == '4488', 'Set trust error, stop the workflow.'

    def install_view(self, vc_server, vm_name, product, build_no, broker_ip, redo=1):  # Retry once if failed

        if product == 'broker':
            install_url_no_revert = 'http://10.136.240.188/webcmd.php?command=installViewSync' \
                                    + '&serverAddress=%s&serverUser=administrator&vmName=%s&type=%s&build=%d&' \
                                      'downloadOnly=false&guestUser=HOVDI%sAdministrator' \
                                      % (vc_server, vm_name, product, build_no, r'%5C')

        if product == 'agent':
            agent_install_parameter = '%2Fs+%2Fv%22%2Fqn+RebootYesNo%3DNo+REBOOT' \
                                      '%3DReallySuppress+SUPPRESS_RUNONCE_CHECK%3D1+ADDLOCAL%3DALL%22'
            install_url_no_revert = 'http://10.136.240.188/webcmd.php?command=installViewSync' + \
                                    '&serverAddress=%s&serverUser=administrator&vmName=%s&type=%s&build=%d&' \
                                    'downloadOnly=false&guestUser=HOVDI%sAdministrator&silentInstallParam=%s' \
                                    % (vc_server, vm_name, product, build_no, r'%5C', agent_install_parameter)

        if product == 'agent-ts':
            install_url_no_revert = 'http://10.136.240.188/webcmd.php?command=installViewSync' \
                                    + '&serverAddress=%s&serverUser=administrator&vmName=%s&type=%s&build=%d&' \
                                      'downloadOnly=false&guestUser=HOVDI%sAdministrator&stdBrokerIp=%s' \
                                      % (vc_server, vm_name, product, build_no, r'%5C', broker_ip)

        return_code = self.request_web_commander(install_url_no_revert, 'install build', 0)

        # if failed, redo once according to ret code
        if return_code != '4488':
            # when installing agent, sometimes you will be asked to reboot the machine, the return_code = 1603
            if return_code == '1603':
                self.restart_vm(vc_server, vm_name)
                time.sleep(300)
                return_code = self.request_web_commander(install_url_no_revert, 'install build', 0)
            elif return_code == '4007':  # return_code = 4007 usually means the vm tools is not running in the vm
                self.update_vm_tools(vc_server, vm_name)
                time.sleep(180)
                return_code = self.request_web_commander(install_url_no_revert, 'install build', 0)
            else:  # otherwise, redo by calling itself recursively
                if redo > 0:
                    return_code = self.install_view(vc_server, vm_name, product, build_no, broker_ip, redo - 1)

        return return_code

    """
        We have only few BATs cases for app test, so do not check the return code
        and make the build continue whether the setup is successful or failed.
    """

    def add_rds_app_pool(self, vc_server, broker_vm, rds_hostname):
        app_path = 'C:\Users\Default\AppData\Roaming\Microsoft\Windows\Start+Menu\Programs\Accessories\Notepad.lnk'
        url_add_farm_with_host = 'http://10.136.240.188/webcmd.php?command=brokerAddFarmWithRdsServer' \
                                 + '&serverAddress=%s&serverUser=administrator&vmName=%s' \
                                   '&guestUser=HOVDI\\Administrator&farmName=rdsh&rdsServerDnsName=%s' \
                                   % (vc_server, broker_vm, rds_hostname)
        # web command brokerAddFarm seems not working
        url_add_app_pool = 'http://10.136.240.188/webcmd.php?command=brokerAddRdsAppPool' + \
                           "&serverAddress=%s&serverUser=administrator&vmName=%s&" \
                           "guestUser=HOVDI\\Administrator&farmId=rdsh&poolId=Notepad&execPath=%s" \
                           % (vc_server, broker_vm, app_path)
        url_entitle = 'http://10.136.240.188/webcmd.php?command=brokerEntitleApplication' + \
                      "&serverAddress=%s&serverUser=administrator&vmName=%s&" \
                      "guestUser=HOVDI\\Administrator&applicationId=Notepad&userName=HOVDI\\Domain+Users" \
                      % (vc_server, broker_vm)
        self.request_web_commander(url_add_farm_with_host, 'url_add_farm_with_host')
        self.request_web_commander(url_add_app_pool, 'url_add_app_pool')
        self.request_web_commander(url_entitle, 'url_entitle')

    def enable_html_access(self, vc_server, broker_vm, pool_name):
        url = 'http://10.136.240.188/webcmd.php?command=brokerSetHtmlAccess' \
              + '&serverAddress=%s&serverUser=administrator&vmName=%s&' \
                'guestUser=HOVDI%sAdministrator&poolId=%s&switch=true' % (vc_server, broker_vm, r'%5c', pool_name)
        self.request_web_commander(url, 'brokerSetHtmlAccess')

    def add_desktop_pool(self, vc_server, broker_vm, pool_name, agent_vm):
        url_remove = 'http://10.136.240.188/webcmd.php?command=brokerRemovePool' + \
                     '&serverAddress=%s&serverUser=administrator&vmName=%s&' \
                     'guestUser=HOVDI%sAdministrator&poolId=%s&rmFromDisk=false' \
                     % (vc_server, broker_vm, r'%5C', pool_name)
        url_add = 'http://10.136.240.188/webcmd.php?command=brokerAddManualPool' + \
                  '&serverAddress=%s&serverUser=administrator&vmName=%s&' \
                  'guestUser=HOVDI%sAdministrator&poolId=%s&vcAddress=%s&agentVmName=%s&poolType=NonPersistent' \
                  % (vc_server, broker_vm, r'%5C', pool_name, vc_server, agent_vm)
        url_entitle = 'http://10.136.240.188/webcmd.php?command=brokerEntitlePool' + \
                      '&serverAddress=%s&serverUser=administrator&vmName=%s&' \
                      'guestUser=HOVDI%sAdministrator&poolId=%s&userName=HOVDI\\Domain+Users' \
                      % (vc_server, broker_vm, r'%5C', pool_name)
        self.request_web_commander(url_remove, 'brokerRemovePool')
        self.request_web_commander(url_add, 'brokerAddManualPool')
        self.request_web_commander(url_entitle, 'brokerEntitlePool')
        self.enable_html_access(vc_server, broker_vm, pool_name)

    def add_license(self, vc_server, broker_vm):
        license_broker = '0M6RH-8T2D2-M8073-023UP-2W462'
        url_add_license = 'http://10.136.240.188/webcmd.php?command=brokerAddLicense' + \
                          '&serverAddress=%s&serverUser=administrator&vmName=%s&license=%s' \
                          % (vc_server, broker_vm, license_broker)
        self.request_web_commander(url_add_license, 'brokerAddLicense')

    def add_vc(self, vc_server, broker_vm):
        add_vc_url = 'http://10.136.240.188/webcmd.php?command=brokerAddVc' + \
                     '&serverAddress=%s&serverUser=administrator&vmName=%s&vcAddress=%s&useComposer=false' \
                     % (vc_server, broker_vm, vc_server)
        self.request_web_commander(add_vc_url, 'brokerAddVc')

    def entitle(self, vc_server, broker_vm, pool_name):
        url_entitle = 'http://10.136.240.188/webcmd.php?command=brokerEntitlePool' + \
                      '&serverAddress=%s&serverUser=administrator&vmName=%s&' \
                      'guestUser=HOVDI%sAdministrator&poolId=%s&userName=HOVDI\\Domain+Users' \
                      % (vc_server, broker_vm, r'%5C', pool_name)
        self.request_web_commander(url_entitle, 'brokerEntitlePool')


"""
 It' used pyVMomi module to get vm information from VC center.

 For more details, please refer to the https://wiki.eng.vmware.com/PyVmomi

"""


class VMUtil(object):
    def __init__(self, host, user, pwd):

        self.host = host
        self.user = user
        self.pwd = pwd

    def __init__(self, host):
        self.host = host
        self.user = 'administrator'
        self.pwd = '******'

    @property
    def vm_summary(self):
        return self.vm_summary

    @vm_summary.setter
    def vm_summary(self, vm_summary):
        self.vm_summary = vm_summary

    @staticmethod
    def get_vm_summary_by_name_internal(virtual_machine, vm_name, depth=1):
        """
        Print information for a particular virtual machine or recurse into a
        folder with depth protection
        """
        max_depth = 10
        # if this is a group it will have children. if it does, recurse into them
        # and then return
        if hasattr(virtual_machine, 'childEntity'):
            if depth > max_depth:
                return
            vm_list = virtual_machine.childEntity
            for c in vm_list:
                VMUtil.get_vm_summary_by_name_internal(c, vm_name, depth + 1)
            return
        summary = virtual_machine.summary
        if summary.config.name == vm_name:
            VMUtil.vm_summary = summary

    @staticmethod
    def get_vm_summary_by_name(host, user, pwd, vm_name, do_connect=True, service_instance=None):

        try:
            if do_connect:
                service_instance = connect.SmartConnect(host=host,
                                                        user=user,
                                                        pwd=pwd)

                atexit.register(connect.Disconnect, service_instance)
            content = service_instance.RetrieveContent()
            children = content.rootFolder.childEntity
            for child in children:
                if hasattr(child, 'vmFolder'):
                    data_center = child
                else:
                    # some other non-datacenter type object
                    continue
                vm_folder = data_center.vmFolder
                vm_list = vm_folder.childEntity
                for virtual_machine in vm_list:
                    VMUtil.get_vm_summary_by_name_internal(virtual_machine, vm_name, 1)
        except Exception, e:
            logger.info(e)

    @staticmethod
    def get_vm_summary_by_name_quick(host, user, pwd, vm_name, do_connect=True, service_instance=None):

        vm_properties = ["name", "config.uuid", "config.hardware.numCPU",
                         "config.hardware.memoryMB", "guest.guestState", "guest.ipAddress", "guest.toolsStatus",
                         "config.guestFullName", "config.guestId",
                         "config.version", "summary"]

        try:
            if do_connect:
                service_instance = connect.SmartConnect(host=host,
                                                        user=user,
                                                        pwd=pwd)

                atexit.register(connect.Disconnect, service_instance)
        except IOError as e:
            pass

        if not service_instance:
            raise SystemExit("Unable to connect to host with supplied info.")

        view = pchelper.get_container_view(service_instance,
                                           obj_type=[vim.VirtualMachine])
        vm_data = pchelper.collect_properties(service_instance, view_ref=view,
                                              obj_type=vim.VirtualMachine,
                                              path_set=vm_properties,
                                              include_mors=True)
        for vm in vm_data:
            if vm["name"] == vm_name:
                return vm["summary"]
        return None

    @staticmethod
    def upload_file_to_vm(host, user, pwd, upload_file, vm_name, vm_path, vm_user, vm_pwd, retry_times=0):
        """
        Simple command-line program for Uploading a file from host to guest

        host, user, pwd : VC
        upload_file :
        vm_name :
        vm_path :
        vm_user :
        vm_pwd :

        """

        ret = False
        try:
            service_instance = connect.SmartConnect(host=host, user=user, pwd=pwd)
            atexit.register(connect.Disconnect, service_instance)
            content = service_instance.RetrieveContent()

            vm_summary = VMUtil.get_vm_summary_by_name_quick(host, user, pwd, vm_name, False, service_instance)
            vm_uuid = str(vm_summary.config.uuid)

            vm = content.searchIndex.FindByUuid(None, vm_uuid, True)

            tools_status = vm.guest.toolsStatus
            if tools_status == 'toolsNotInstalled' or tools_status == 'toolsNotRunning':
                raise SystemExit(
                    "VMwareTools is either not running or not installed. "
                    "Rerun the script after verifying that VMWareTools "
                    "is running")

            creds = vim.vm.guest.NamePasswordAuthentication(
                username=vm_user, password=vm_pwd
            )

            with open(upload_file, 'rb') as myfile:
                args = myfile.read()

            try:
                file_attribute = vim.vm.guest.FileManager.FileAttributes()
                url = content.guestOperationsManager.fileManager.InitiateFileTransferToGuest(vm, creds,
                                                                                             vm_path, file_attribute,
                                                                                             len(args), True)

                resp = requests.put(url, data=args, verify=False)
                if not resp.status_code == 200:
                    logger.info("Error while uploading file")
                else:
                    logger.info("Successfully uploaded file")
                    ret = True
            except IOError, e:
                logger.info(e)
        except vmodl.MethodFault as error:
            logger.info("Caught vmodl fault : " + error.msg)
            if retry_times < 5:
                retry_times += 1
                VMUtil.upload_file_to_vm(host, user, pwd, upload_file, vm_name, vm_path, vm_user, vm_pwd, retry_times)
        finally:
            return ret

    @staticmethod
    def execute_program_in_vm(host, user, pwd, vm_name, program, para, vm_user, vm_pwd, wait_result=True, timeout=3600):
        """

         Return : the exit code of the program. Timeout is one hour.

        """
        try:
            service_instance = connect.SmartConnect(host=host, user=user, pwd=pwd)

            atexit.register(connect.Disconnect, service_instance)
            content = service_instance.RetrieveContent()

            vm_summary = VMUtil.get_vm_summary_by_name_quick(host, user, pwd, vm_name, False, service_instance)
            vm_uuid = str(vm_summary.config.uuid)

            vm = content.searchIndex.FindByUuid(None, vm_uuid, True)

            tools_status = vm.guest.toolsStatus
            if tools_status == 'toolsNotInstalled' or tools_status == 'toolsNotRunning':
                raise SystemExit(
                    "VMwareTools is either not running or not installed. "
                    "Rerun the script after verifying that VMwareTools "
                    "is running")

            creds = vim.vm.guest.NamePasswordAuthentication(
                username=vm_user, password=vm_pwd
            )

            try:
                pm = content.guestOperationsManager.processManager
                ps = vim.vm.guest.ProcessManager.ProgramSpec(
                    programPath=program,
                    arguments=para
                )

                res = pm.StartProgramInGuest(vm, creds, ps)

                if res > 0:
                    logger.info("Program executed, PID is %d" % res)

                if wait_result:
                    interval = 100
                    while True:
                        try:
                            if timeout <= 0:
                                logger.info(' execute program in vm reaching timeout, error.')
                                return -1

                            process_info = pm.ListProcessesInGuest(vm=vm, auth=creds, pids=[res])
                            if process_info[0].endTime != None:
                                logger.info(' execute program exit with code : ' + str(process_info[0].exitCode))
                                return process_info[0].exitCode

                        except Exception, e:
                            continue
                        timeout -= interval
                        time.sleep(interval)

                    return -1
                else:
                    ''' if no need to wait result, just return 0. '''
                    return 0
            except IOError, e:
                logger.info(e)
                return -1
        except vmodl.MethodFault as error:
            logger.info(error)
            logger.info("Caught vmodl fault : " + error.msg)
            return -1


class BrokerUtil(object):
    def __init__(self, host, user, pwd, domain):
        import PowershellServiceClient
        self.host = host
        self.user = user
        self.pwd = pwd
        self.domain = domain
        self.broker_instance = PowershellServiceClient.PowershellServiceClient()

    def connect(self):
        self.broker_instance.connect(self.host, self.user, self.pwd, self.domain)


class Utilities(object):
    def __init__(self):
        pass

    @staticmethod
    def unzip(infile, path):

        zip = zipfile.ZipFile(infile, 'r')

        # If the output location does not yet exist, create it
        #
        if not isdir(path):
            os.makedirs(path)

        for each in zip.namelist():

            # Check to see if the item was written to the zip file with an
            # archive name that includes a parent directory. If it does, create
            # the parent folder in the output workspace and then write the file,
            # otherwise, just write the file to the workspace.
            #
            if not each.endswith('/'):
                root, name = split(each)
                directory = normpath(join(path, root))
                if not isdir(directory):
                    os.makedirs(directory)
                file(join(directory, name), 'wb').write(zip.read(each))

        zip.close()

    @staticmethod
    def get_installed_product_version(ip):
        ''' So far only support 64 bit '''
        product_version = ''
        try:
            result = STAFHelper.run_command_sync4(ip, 'reg query \"HKEY_LOCAL_MACHINE\\SOFTWARE\\VMware, Inc.'
                                                      '\\VMware VDM\"')
            mc = unmarshall(result.result)
            entry_map = mc.getRootObject()
            product_version = entry_map['fileList'][0]['data'].split('\r\n')[2].split(' ')[-1]
        except IOError, e:
            logger.info(e)
            product_version = None
        finally:
            return product_version

    @staticmethod
    def enable_fips(vc_server=None, vm=None, is_vm_machine=True, ip=None):
        if is_vm_machine:
            VMUtil.execute_program_in_vm(vc_server, VC_cred.user, VC_cred.pwd, vm, "c:\\Windows\\System32\\reg.exe",
                                         "add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\"
                                         "FipsAlgorithmPolicy\" /v Enabled /t REG_DWORD /d 1 /f", Domain_cred.user,
                                         Domain_cred.pwd)
        else:
            logger.info(' Will use STAF to do this. ')
            STAFHelper.run_command_sync3(ip, 'reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa'
                                             '\\FipsAlgorithmPolicy\" /v Enabled /t REG_DWORD /d 1 /f')


class AbstractBATsEnvBase(object):
    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def config(self, bats_env_parameters):
        return

    @abc.abstractmethod
    def install(self, bats_env_parameters, queue):
        return

    @abc.abstractmethod
    def install2(self, bats_env_parameters, queue):
        return

    @abc.abstractmethod
    def valid_installation(self, bats_env_parameters, handle):
        return


class AgentRunner(AbstractBATsEnvBase):
    def __init__(self):
        self.webCommander = WebCommander()
        self.log_pre = '[ Agent ] '

    @property
    def agent_ip(self):
        return self.agent_ip

    @agent_ip.setter
    def agent_ip(self, ip):
        self.agent_ip = ip

    def config(self, bats_env_parameters, queue):
        ret = False
        try:
            self.webCommander.add_desktop_pool(bats_env_parameters.vc_server, bats_env_parameters.broker_vm,
                                               bats_env_parameters.parameters.pool_name, bats_env_parameters.agent_vm)
            if not bats_env_parameters.legacy_agent:
                self.webCommander.power_off_on_vm(bats_env_parameters.vc_server, bats_env_parameters.agent_vm)
            time.sleep(120)
            logger.info('Agent all done with success.')
            ret = True
        except Exception, e:
            logger.info(e)
        finally:
            queue.put(ret)

    '''
        Before install, it will revert screen shot and copy the installer to the remote machine.

        And restart the machine to avoid the 1618 error. -- Drop it as change to API to execute program in the VM.

    '''

    def before_install(self, bats_env_parameters):
        ret = False
        try:
            self.webCommander.install_prepare(bats_env_parameters.vc_server, bats_env_parameters.agent_vm)

            if bats_env_parameters.parameters.enable_fips:
                Utilities.enable_fips(vc_server=bats_env_parameters.vc_server, vm=bats_env_parameters.broker_vm)

            ''' As the restoration may change the IP address, so here just refresh the IP. '''
            vm_summary = VMUtil.get_vm_summary_by_name_quick(bats_env_parameters.vc_server,
                                                             VC_cred.user,
                                                             VC_cred.pwd,
                                                             bats_env_parameters.agent_vm)
            vm_agent_ip = vm_summary.guest.ipAddress
            self.agent_ip = vm_agent_ip
            if self.agent_ip is None:
                return
            logger.info(' copy the agent installer file to the remote agent. ')
            STAFHelper.copy_from_local_to_remote_temp(bats_env_parameters.parameters.agent_build_path,
                                                      self.agent_ip)
            ''' Add time buffer here is because catch the 1618 error if start the installation right now. '''
            time.sleep(100)
            ret = True
        except Exception, e:
            ret = False
            logger.info(e)
        finally:
            return ret

    '''
        This install depends on the web commander, it's hard to handle the error of installation.

        In this case, just use the install2.

    '''

    def install(self, bats_env_parameters, queue):
        ret = False
        try:
            if not bats_env_parameters.legacy_agent:
                if self.webCommander.install_view(bats_env_parameters.vc_server, bats_env_parameters.agent_vm, 'agent',
                                                  int(bats_env_parameters.parameters.broker_build_no),
                                                  bats_env_parameters.broker_ip) != '4488':
                    logger.info("install agent fail, no need to do the further testing..")
            ret = True
        except Exception, e:
            logger.info(e)
        finally:
            queue.put(ret)

    @staticmethod
    def install_internal(bats_env_parameters):
        ret = False
        try:
            """ Install the MSI. """
            # Now get the latest view broker build path from local.
            # Refer to the do_prepare_setting() to get more details.
            installer_path = os.path.join('C:\\temp', os.path.basename(bats_env_parameters.parameters.agent_build_path))
            # run the installer
            logger.info(">>> Starting view agent installer")

            if bats_env_parameters.parameters.enable_fips:
                msi_v_args = '"/qn ' \
                             'RebootYesNo=No ' \
                             'REBOOT=ReallySuppress ' \
                             'SUPPRESS_RUNONCE_CHECK=1 ' \
                             'VDM_FIPS_ENABLED=1 ' \
                             'ADDLOCAL=\"VmVideo,RTAV,SVIAgent,ScannerRedirection,SerialPortRedirection,SmartCard,' \
                             'TSMMR,ThinPrint,USB,V4V,VPA,VmwVaudio,RDP,Core,BlastProtocol,ClientDriveRedirection,' \
                             'PCoIP,UnityTouch,FLASHMMR\""'
            else:
                msi_v_args = '"/qn ' \
                             'RebootYesNo=No ' \
                             'REBOOT=ReallySuppress ' \
                             'SUPPRESS_RUNONCE_CHECK=1 ' \
                             'ADDLOCAL=\"VmVideo,RTAV,SVIAgent,ScannerRedirection,SerialPortRedirection,SmartCard,' \
                             'TSMMR,ThinPrint,USB,V4V,VPA,VmwVaudio,RDP,Core,BlastProtocol,ClientDriveRedirection,' \
                             'PCoIP,UnityTouch,FLASHMMR\""'

            cmd_and_args = [
                # installer_path,
                '/s',  # MSI slient install
                '/v',  # MSI /v option
                msi_v_args]
            logger.info('Starting subprocess:\n    %s' % (' '.join(cmd_and_args)))

            staf_command = ' '.join(cmd_and_args)
            result_install_agent = VMUtil.execute_program_in_vm(bats_env_parameters.vc_server, VC_cred.user,
                                                                VC_cred.pwd, bats_env_parameters.agent_vm,
                                                                installer_path, staf_command, Domain_cred.user,
                                                                Domain_cred.pwd)
            if result_install_agent == 0 or result_install_agent == 3010:
                logger.info("Agent installation is done with success.")
                ret = True
            else:
                logger.info("Agent installation is done with fail, error code is : " + str(result_install_agent))

        except Exception, e:
            ret = False
            logger.info(e)
        finally:
            return ret

    def install2(self, bats_env_parameters, queue, times=1):
        ret = False
        try:
            if AgentRunner.needs_install(bats_env_parameters):
                ''' Try one more time for the installation failure. '''
                if not self.before_install(bats_env_parameters):
                    if not self.before_install(bats_env_parameters):
                        logger.info('Agent installation before error, break the installation.')
                        return
                if not AgentRunner.install_internal(bats_env_parameters):
                    if times != 2:
                        if not self.install2(bats_env_parameters, queue, times=2):
                            logger.info('Agent installation error, break the installation.')
                            return
                    else:
                        return
                ret = True
            else:
                ret = True
        except Exception, e:
            logger.info(e)
        finally:
            queue.put(ret)

    ''' No need to do the validation here, just use it as a marker. '''

    def valid_installation(self, handle):
        return True

    """
        To compare the installed build version with the latest recommend build version,
        if same, not need to do the installation.

        TODO: To handle the power off state of vm machine.

    """

    @staticmethod
    def needs_install(bats_env_parameters):
        vm_summary = VMUtil.get_vm_summary_by_name_quick(bats_env_parameters.vc_server,
                                                         VC_cred.user,
                                                         VC_cred.pwd,
                                                         bats_env_parameters.agent_vm)
        vm_agent_ip = vm_summary.guest.ipAddress
        if vm_agent_ip == '' or vm_agent_ip == None:
            return True
        AgentRunner.agent_ip = vm_agent_ip

        installed_build_version = Utilities.get_installed_product_version(vm_agent_ip)
        logger.info('Agent installed build : ' + installed_build_version)
        if installed_build_version != None:
            if installed_build_version.find(str(bats_env_parameters.parameters.agent_build_no)) != -1:
                return False
        return True


class BrokerRunner(AbstractBATsEnvBase):
    def __init__(self):
        self.webCommander = WebCommander()
        self.handle = ''

    def config(self, bats_env_parameters):
        """ Still leverage features of web commander here. """
        self.webCommander.add_license(bats_env_parameters.vc_server, bats_env_parameters.broker_vm)
        self.webCommander.add_vc(bats_env_parameters.vc_server, bats_env_parameters.broker_vm)

        """
        Enable NativeBlast, ServerInDesktop,
        Lagecy Agent -- Config Broker, will merge the code in the batch file to python.
        """
        logger.info("Enable NativeBlast, ServerInDesktop, Lagecy Agent")
        STAFHelper.run_command_async(bats_env_parameters.broker_ip,
                                     '//10.117.45.89/view/tools/scripts/BAT/AllowAllThree.bat')
        time.sleep(180)
        logger.info("Broker all done with success.")

        return True

    @staticmethod
    def after_install(bats_env_parameters):
        """
            All of these workflow are followed the web commander to config broker.
            Any question, please refer to the source code of web commander
            at installview.ps(The part of install broker).

        :param bats_env_parameters:
        :param queue:
        """
        ret = False
        try:
            '''unzip the viewtest to temp folder'''
            Utilities.unzip(bats_env_parameters.parameters.view_test_build_path, 'c:/temp')

            '''back up the dll file and replace with test dll'''
            logger.info('back up the dll file and replace with test dll')
            cmd_let_dll = 'C:/Program Files/VMware/VMware View/Server/bin/PowershellServiceCmdlets.dll'
            cmd_let_dll_bk = 'C:/Program Files/VMware/VMware View/Server/bin/PowershellServiceCmdlets.dll.orig'
            STAFHelper.copy_from_remote_to_remote(cmd_let_dll, cmd_let_dll_bk, bats_env_parameters.broker_ip)
            STAFHelper.fs_request(bats_env_parameters.broker_ip, 'DELETE ENTRY %s CONFIRM' % cmd_let_dll)
            cmd_let_dll_view_test = 'C:/temp/powershell.dir/PowershellServiceCmdlets-Ext64.dll'
            STAFHelper.copy_from_local_to_remote(cmd_let_dll_view_test, cmd_let_dll, bats_env_parameters.broker_ip)

            ''' install the test dll '''
            logger.info('install the test dll')
            result = STAFHelper.fs_request(bats_env_parameters.broker_ip,
                                           'list directory c:/windows/Microsoft.Net/Framework64/ recurse name InstallUtil')
            install_util_path = 'c:/windows/Microsoft.Net/Framework64/' + result.resultObj[0].replace("\\", "/")
            cmd_let_dll = "\\\"" + cmd_let_dll + "\\\""
            STAFHelper.run_command_sync(bats_env_parameters.broker_ip,
                                        "\"" + install_util_path + " " + cmd_let_dll + "\"")
            '''
                set the exection policy, here only can run with async mode with STAF, cannot track the real rc.
                only wait 20 seconds here.
            '''
            logger.info('set the exection policy')
            rc_set_power_shell = STAFHelper.run_command_async(bats_env_parameters.broker_ip,
                                                              'powershell.exe -ExecutionPolicy UNRESTRICTED')
            time.sleep(20)

            ''' unzip and config api operator '''
            logger.info('unzip and config api operator')
            api_opt_path = os.path.join('C:/temp/',
                                        os.path.basename(bats_env_parameters.parameters.view_api_operator_build_path))
            STAFHelper.copy_from_local_to_remote_temp(bats_env_parameters.parameters.view_api_operator_build_path,
                                                      bats_env_parameters.broker_ip)

            rc_zip = STAFHelper.run_command_sync(bats_env_parameters.broker_ip,
                                                 '//10.117.45.89/view/tools/WinBATool/7-Zip/7z.exe x %s -o%s -y' %
                                                 (api_opt_path, 'C:/temp/'))
            assert int(rc_zip) == 0, 'unzip operator api error.'

            logger.info('copy the default api xml file.')
            view_api_cli_defaults_local = 'c:/BATs/viewapicli-defaults_' + bats_env_parameters.broker_ip + '.xml'
            view_api_cli_defaults_remote = 'c:/temp/view-api-operator/viewapicli-defaults.xml'
            STAFHelper.copy_from_local_to_remote(view_api_cli_defaults_local,
                                                 view_api_cli_defaults_remote, bats_env_parameters.broker_ip)

            STAFHelper.run_command_sync(bats_env_parameters.broker_ip,
                                        '//10.117.45.89/view/tools/scripts/BAT/addClientSSLSecureProtocols.bat')
            time.sleep(150)

            broker_name = STAFHelper.get_computer_name(bats_env_parameters.broker_ip)
            logger.info('Broker Name is : ' + broker_name)

            STAFHelper.run_command_async(bats_env_parameters.broker_ip,
                                         '//10.117.45.89/view/tools/scripts/Wincdk_BATs_config_broker.bat %s %s' %
                                         (broker_name, bats_env_parameters.broker_ip))
            time.sleep(150)
            ret = True
        except Exception, e:
            logger.info(e)
        finally:
            return ret

    def install(self, bats_env_parameters, queue):
        ret = False
        try:
            if self.webCommander.install_view(bats_env_parameters.vc_server, bats_env_parameters.broker_vm, 'broker',
                                              int(bats_env_parameters.parameters.broker_build_no),
                                              bats_env_parameters.broker_ip) == '4488':
                self.webCommander.add_license(bats_env_parameters.vc_server, bats_env_parameters.broker_vm)
                self.webCommander.add_vc(bats_env_parameters.vc_server, bats_env_parameters.broker_vm)
                """
                Enable NativeBlast, ServerInDesktop,
                Lagecy Agent -- Config Broker, will merge the code in the batch file to python.
                """
                STAFHelper.staf.run_command_async(bats_env_parameters.broker_ip,
                                                  r'\\10.117.45.89\view\tools\scripts\BAT\AllowAllThree.bat')
                time.sleep(180)
                ret = True
            else:
                logger.info("install broker fail, no need to do the further testing..")
        except Exception, e:
            logger.info(e)
        finally:
            queue.put(ret)

    ''' here is just do some prepare work for the installation. '''
    def before_install(self, bats_env_parameters):
        ret = False
        try:
            self.webCommander.install_prepare(bats_env_parameters.vc_server, bats_env_parameters.broker_vm)

            if bats_env_parameters.parameters.enable_fips:
                Utilities.enable_fips(vc_server=bats_env_parameters.vc_server, vm=bats_env_parameters.broker_vm)

            STAFHelper.copy_from_local_to_remote_temp(bats_env_parameters.parameters.broker_build_path,
                                                      bats_env_parameters.broker_ip)
            time.sleep(60)

            logger.info('before install, delete all the install logs if exists.')
            result = STAFHelper.fs_request(bats_env_parameters.broker_ip,
                                           'list directory %temp% name vmmsi.log*')
            vmmsi_log_path_list = result.resultObj
            ' if exists, then delete it.'
            if not vmmsi_log_path_list:
                for log in vmmsi_log_path_list:
                    STAFHelper.fs_request(bats_env_parameters.broker_ip,
                                          'delete entry %temp%/' + log + ' confirm')

            time.sleep(30)
            ret = True
        except Exception, e:
            ret = False
            logger.info(e)
        finally:
            return ret

    def install2(self, bats_env_parameters, queue, times=1):
        ret = False
        try:
            if BrokerRunner.needs_install(bats_env_parameters):
                ''' Try one more time for the installation failure. '''
                if not self.before_install(bats_env_parameters):
                    if not self.before_install(bats_env_parameters):
                        logger.info('Broker installation before error, break the installation.')
                        return
                if not BrokerRunner.install_internal(bats_env_parameters):
                    if times != 2:
                        if not self.install2(bats_env_parameters, queue, times=2):
                            logger.info('Broker installation error, break the installation.')
                            return
                    else:
                        return
                if not self.after_install(bats_env_parameters):
                    if not self.after_install(bats_env_parameters):
                        logger.info('Broker installation after error, break the installation.')
                        return
                if not self.config(bats_env_parameters):
                    if not self.config(bats_env_parameters):
                        logger.info('Broker installation config error, break the installation.')
                        return
                ret = True
            else:
                ret = True
        except Exception, e:
            logger.info(e)
        finally:
            queue.put(ret)

    @staticmethod
    def install_internal(bats_env_parameters):
        ret = False
        try:
            """ Install the MSI. """
            # Now get the latest view broker build path from local.
            # Refer to the do_prepare_setting() to get more details.
            installer_path = os.path.join('C:\\temp',
                                          os.path.basename(bats_env_parameters.parameters.broker_build_path))
            # run the installer
            logger.info(">>> Starting view broker installer ...")

            if bats_env_parameters.parameters.enable_fips:
                msi_v_args = '/qn ' \
                             'ADDLOCAL=ALL ' \
                             'VDM_SERVER_INSTANCE_TYPE=1 ' \
                             'VDM_FIPS_ENABLED=1 ' \
                             'VDM_SERVER_RECOVERY_PWD=111111'
            else:
                msi_v_args = '/qn ' \
                             'ADDLOCAL=ALL ' \
                             'VDM_SERVER_INSTANCE_TYPE=1 ' \
                             'VDM_SERVER_RECOVERY_PWD=111111'

            cmd_and_args = [
                # installer_path,
                '/s',  # MSI slient install
                '/v',  # MSI /v option
                msi_v_args]
            logger.info('Starting subprocess:\n    %s' % (' '.join(cmd_and_args)))

            staf_command = ' '.join(cmd_and_args)
            result_install_broker = VMUtil.execute_program_in_vm(bats_env_parameters.vc_server, VC_cred.user,
                                                                 VC_cred.pwd, bats_env_parameters.broker_vm,
                                                                 installer_path, staf_command, Domain_cred.user,
                                                                 Domain_cred.pwd)

            if result_install_broker == 0 or result_install_broker == 3010:
                logger.info("Broker installation is done with success.")
                ret = True
            else:
                logger.info("Broker installation is done with fail, error code is : " + str(result_install_broker))
        except Exception, e:
            logger.info(e)
        finally:
            return ret

    @staticmethod
    def valid_installation(bats_env_parameters, handle):
        return True

    @staticmethod
    def needs_install(bats_env_parameters):
        return True


class RDSHRunner(AbstractBATsEnvBase):
    def __init__(self):
        self.webCommander = WebCommander()

    @property
    def rdsh_ip(self):
        return self.rdsh_ip

    @rdsh_ip.setter
    def rdsh_ip(self, ip):
        self.rdsh_ip = ip

    def config(self, bats_env_parameters, queue):
        ret = False
        try:
            ret = True
        except Exception, e:
            logger.info(e)
        finally:
            queue.put(ret)

    '''
        Before install, it will revert screen shot and copy the installer to the remote machine.

        And restart the machine to avoid the 1618 error.

    '''

    def before_install(self, bats_env_parameters):
        ret = False
        try:
            self.webCommander.install_prepare(bats_env_parameters.vc_server, bats_env_parameters.rds_vm)

            ''' As the restoration may change the IP address, so here just refresh the IP. '''
            logger.info(' copy the rdsh installer file to the remote agent. ')
            # here need to try the upload file util by vm.
            # STAFHelper.copy_from_local_to_remote_temp(bats_env_parameters.parameters.agent_build_path,
            #                                           self.rdsh_ip)

            build_target_path = os.path.basename(bats_env_parameters.parameters.rdsh_build_path)
            VMUtil.upload_file_to_vm(bats_env_parameters.vc_server, VC_cred.user, VC_cred.pwd,
                                     bats_env_parameters.parameters.rdsh_build_path, bats_env_parameters.rds_vm,
                                     'c:\\' + build_target_path, Domain_cred.user, Domain_cred.pwd)
            ''' Add time buffer here is because catch the 1618 error if start the installation right now. '''
            time.sleep(100)
            ret = True
        except Exception, e:
            ret = False
            logger.info(e)
        finally:
            return ret

    @staticmethod
    def install_internal(bats_env_parameters):
        ret = False
        try:
            """ Install the MSI. """
            # Now get the latest view broker build path from local.
            # Refer to the do_prepare_setting() to get more details.
            installer_path = os.path.join('C:\\', os.path.basename(bats_env_parameters.parameters.rdsh_build_path))
            # run the installer
            logger.info(">>> Starting view agent installer")

            msi_v_args = '"/qn ' \
                         'RebootYesNo=No ' \
                         'REBOOT=ReallySuppress ' \
                         'SUPPRESS_RUNONCE_CHECK=1 ' \
                         'ADDLOCAL=ALL" ' \
                         'VDM_SERVER_USERNAME=hovdi/administrator" ' \
                         'VDM_SERVER_PASSWORD=******" ' \
                         'VDM_SERVER_NAME="' + bats_env_parameters.broker_ip

            cmd_and_args = [
                # installer_path,
                '/s',  # MSI slient install
                '/v',  # MSI /v option
                msi_v_args]
            logger.info('Starting subprocess:\n    %s' % (' '.join(cmd_and_args)))

            staf_command = ' '.join(cmd_and_args)
            result_install_agent = VMUtil.execute_program_in_vm(bats_env_parameters.vc_server, VC_cred.user,
                                                                VC_cred.pwd, bats_env_parameters.rds_vm,
                                                                installer_path, staf_command, Domain_cred.user,
                                                                Domain_cred.pwd)
            if result_install_agent == 0 or result_install_agent == 3010:
                logger.info("Agent installation is done with success.")
                ret = True
            else:
                logger.info("Agent installation is done with fail, error code is : " + str(result_install_agent))

        except Exception, e:
            ret = False
            logger.info(e)
        finally:
            return ret

    def install(self, bats_env_parameters, queue):
        ret = False
        try:
            self.webCommander.install_prepare(bats_env_parameters.vc_server, bats_env_parameters.rds_vm)

            if self.webCommander.install_view(bats_env_parameters.vc_server, bats_env_parameters.rds_vm, 'agent-ts',
                                              int(bats_env_parameters.parameters.agent_build_no),
                                              bats_env_parameters.broker_ip) != '4488':
                logger.info("install RDSH fail, but to do the further testing..")
                return
            self.webCommander.add_rds_app_pool(bats_env_parameters.vc_server, bats_env_parameters.broker_vm,
                                               bats_env_parameters.rds_hostname)
            self.webCommander.restart_vm(bats_env_parameters.rds_vm)
            # After entitle app pool with the same user, the entitlement of desktop pool will be lost. So re-add
            if not bats_env_parameters.skip_agent:
                self.webCommander.entitle(bats_env_parameters.vc_server, bats_env_parameters.broker_vm,
                                          bats_env_parameters.parameters.pool_name)
            ret = True
        except Exception, e:
            logger.info(e)
        finally:
            queue.put(ret)

    '''

        RDSH doesn't install STAF, so here just leverage the web commander.
        Update: Here is just try to use vm utility function to upload installer file.

    '''

    def install2(self, bats_env_parameters, queue, times=1):
        ret = False
        try:
            if RDSHRunner.needs_install(bats_env_parameters):
                ''' Try one more time for the installation failure. '''
                if not self.before_install(bats_env_parameters):
                    if not self.before_install(bats_env_parameters):
                        logger.info('RDSH installation before error, break the installation.')
                        return
                if not RDSHRunner.install_internal(bats_env_parameters):
                    if times != 2:
                        if not self.install2(bats_env_parameters, queue, times=2):
                            logger.info('RDSH installation error, break the installation.')
                            return
                    else:
                        return
                ret = True
            else:
                ret = True
        except Exception, e:
            logger.info(e)
        finally:
            queue.put(ret)

    @staticmethod
    def valid_installation(vm_agent_ip, handle):
        pass

    @staticmethod
    def needs_install(bats_env_parameters):
        return True


class ClientRunner(AbstractBATsEnvBase):

    def __init__(self, bats_env_parameters):
        self.bats_env_parameters = bats_env_parameters
        (self.clientIP, self.clientName) = ClientRunner.get_client_ip_name(bats_env_parameters)
        self.clientIP = self.get_valid_client_ip()
        assert (self.clientIP != 'NA'), "Client is not up now, please to check the physical machine."
        assert (self.bats_env_parameters.parameters.client_branch != '')
        # build num is optional parameter, no need to valid here.
        assert (self.bats_env_parameters.parameters.client_image != 'NULL')

    def config(self, bats_env_parameters):
        """
            Just refactor code to run test cases in client side.
            Do not familiar with the details.

        """
        select_bat_env = self.bats_env_parameters.parameters.select_bat_env[3:]
        ''' It's should be the required step for the client exection, will enhance later. '''
        STAFHelper.run_command_sync(self.clientIP, 'echo %s > c:/buildnum.txt' % self.bats_env_parameters.
                                    parameters.client_build_num)
        STAFHelper.run_command_sync(self.clientIP, 'echo %s > c:/obsb.txt' % self.bats_env_parameters.
                                    parameters.client_build_type)

        assert STAFHelper.run_command_sync3(self.clientIP,
                                            'copy /y \\\\10.117.45.89\\view\\tools\\scripts\\LoadEnv-'
                                            '%s.bat c:\\LoadEnv.bat' % select_bat_env).rc == 0, 'copy env file error.'
        assert STAFHelper.run_command_sync3(self.clientIP,
                                            'copy /D /Y \\\\10.117.45.89\\view\\tools\\scripts\\BAT C:\\').rc == 0, \
            'copy BAT files error.'

        time.sleep(20)

    def __wait_client_up(self, timeout=3600, interval=300):
        ret = False
        elapsed_time = 0
        logger.info("Ping with new method " + self.clientIP + "...")
        while elapsed_time < timeout:
            try:
                output = subprocess.check_output("ping -n 1 " + self.clientIP)
                if 'TTL=' in output:
                    logger.info(self.clientIP + " is online!")
                    ret = True
                    break
            except Exception, e:
                continue
            elapsed_time += interval
            time.sleep(interval)
        return ret

    def verify_client_via_ip(self):
        return self.__wait_client_up()

    def verify_client_via_staf(self):
        return STAFHelper.staf_ping_timeout(self.clientIP)

    def get_ip_2(self):
        try:
            return socket.gethostbyname(self.clientName)
        except Exception, e:
            return "NA"

    def get_valid_client_ip(self):
        if not self.verify_client_via_staf():
            return self.get_ip_2()
        return self.clientIP

    def get_client_arch(self):
        arch = ''
        result = STAFHelper.submit(self.clientIP, 'var', 'resolve string {STAF/Env/PROCESSOR_ARCHITECTURE}')
        assert result.rc == 0, 'get client arch error.'
        if result.resultObj.lower().find('64') != -1:
            arch = '64'
        if result.resultObj.lower().find('86') != -1:
            arch = '32'
        return arch

    def restore(self):
        ret = False
        try:
            logger.info(' start the restoring... ')
            assert bool(self.verify_client_via_staf()), "STAF is not running on the client, quit."
            self.go_into_winpe()

            ''' Ping success, means that the machine doesn't go into the WinPE success. So, do it again. '''
            if STAFHelper.staf_ping(self.clientIP):
                self.go_into_winpe()

            # Wait up to 1 hr for the system to be restored and start up.
            assert bool(self.verify_client_via_ip()), "The client cannot be reached by Ping IP after 1 hr."
            assert bool(self.verify_client_via_staf()), "The client cannot be reached by STAF after restoring, " \
                                                        "canceling the job. Known issue is: Cannot login with hovdi/admin"
            logger.info(' restoring success... ')
            ret = True
        except Exception, e:
            logger.info(e)
            ret = False
        finally:
            return ret

    def go_into_winpe(self):
        restore_image_command = 'cmd /k C:/tests/SCRestore.bat ' + \
                                self.bats_env_parameters.parameters.client_image + ' NEWCONSOLE'
        logger.info(restore_image_command)
        STAFHelper.run_command_async(self.clientIP, restore_image_command)
        time.sleep(5)
        """After these two commands, the client should be restarted, go into the WINPE to do the restoring."""
        """Then, here just use the ping IP to verify the whether the restoring is done."""
        STAFHelper.run_command_async(self.clientIP, 'shutdown /r /f')
        # wait 2 minutes before pinging it, to make sure the previous shutdown command has taken place.
        time.sleep(120)

    def __before_install(self, bats_env_parameters):
        if self.restore():
            if bats_env_parameters.parameters.enable_fips:
                Utilities.enable_fips(is_vm_machine=False, ip=self.clientIP)
            return True
        else:
            return False

    def install(self, bats_env_parameters, queue):
        ret = False
        try:
            if self.__before_install(bats_env_parameters) and self.install2(bats_env_parameters):
                self.config(bats_env_parameters)
                ret = True
        except Exception, e:
            logger.info(e)
        finally:
            queue.put(ret)

    def install2(self, bats_env_parameters):
        ret = False
        try:
            client_build_path = ''

            if self.get_client_arch() == '64':
                STAFHelper.copy_from_local_to_remote_temp(bats_env_parameters.parameters.client_build_path_64,
                                                          self.clientIP)
                client_build_path = bats_env_parameters.parameters.client_build_path_64
            if self.get_client_arch() == '32':
                STAFHelper.copy_from_local_to_remote_temp(bats_env_parameters.parameters.client_build_path_32,
                                                          self.clientIP)
                client_build_path = bats_env_parameters.parameters.client_build_path_32

            """ Install the MSI. """
            # Now get the latest view broker build path from local.
            # Refer to the do_prepare_setting() to get more details.
            installer_path = os.path.join('C:/temp/', os.path.basename(client_build_path))
            # run the installer
            logger.info(">>> Starting view client installer")

            if bats_env_parameters.parameters.enable_fips:
                msi_v_args = '"/qn ' \
                             'RebootYesNo=No ' \
                             'REBOOT=ReallySuppress ' \
                             'VDM_FIPS_ENABLED=1 ' \
                             'ADDLOCAL=ALL "'
            else:
                msi_v_args = '"/qn ' \
                             'RebootYesNo=No ' \
                             'REBOOT=ReallySuppress ' \
                             'ADDLOCAL=ALL "'

            cmd_and_args = [
                installer_path,
                '/s',  # MSI slient install
                '/v',  # MSI /v option
                msi_v_args]
            logger.info('Starting subprocess:\n    %s' % (' '.join(cmd_and_args)))
            try:
                staf_command = ' '.join(cmd_and_args)
                result_install_client = STAFHelper.run_command_async(self.clientIP, staf_command)
                if result_install_client.rc == 0:
                    'No need to check the installation result immeditally, just wait 5 minutes here.'
                    time.sleep(5)
                    ret = self.valid_installation(str(result_install_client.resultObj))
                else:
                    logger.info("Installation failed with error code %d" % result_install_client.rc)
                    return

            except Exception as ex:
                logger.info(ex)
                ret = False

            logger.info("Client installation success, then to restart.")
            STAFHelper.run_command_async(bats_env_parameters.broker_ip, 'shutdown -r -t 0')
            ''' Here just set the timeout to 15 minutes. '''
            time.sleep(60)
            ret = STAFHelper.staf_ping_timeout(bats_env_parameters.broker_ip, timeout=900)
            logger.info("Client restart status %s" % str(ret))
            if ret:
                logger.info("Client all done with success")
        except Exception as ex1:
            ret = False
            logger.info(ex1)
        finally:
            return ret

    def valid_installation(self, handle):
        timeout = 40 * 60
        elapsed_time = 0
        logger.info(' Start the validation of client installation. Timeout is 40 minutes. ')
        while elapsed_time < timeout:
            try:
                result_query_handle = STAFHelper.submit(self.clientIP,
                                                        'process', 'query handle %s' % handle)
                assert result_query_handle.rc == 0, 'client installation process was fail to query, please check.'
                mc = unmarshall(result_query_handle.result)
                entry_map = mc.getRootObject()
                if None != entry_map['endTimestamp']:
                    if entry_map['rc'] == '0' or entry_map['rc'] == '3010':
                        logger.info('The client installation is done with success. ')
                        return True
                    else:
                        logger.info('The client installation is done with fail, will check the installation logs, '
                                    'Result : ' + entry_map['rc'])
                        return False
            except Exception as e:
                logger.info(e)
                pass
            elapsed_time += 60
            time.sleep(60)

    def run_tc(self):
        """
            trigger the test cases run in the client side.

        """
        logger.info('c:/wincdk-run-protocol-noinst.bat /N %s /B %s /O ob /S WinCDKBATs' %
                    (self.bats_env_parameters.parameters.client_build_num,
                     self.bats_env_parameters.parameters.client_branch))

        STAFHelper.run_command_async(self.clientIP,
                                     'c:/wincdk-run-protocol-noinst.bat /N %s /B %s /O ob /S WinCDKBATs' %
                                     (self.bats_env_parameters.parameters.client_build_num,
                                      self.bats_env_parameters.parameters.client_branch))

    @staticmethod
    def get_client_ip_name(bats_env_parameters):
        client = bats_env_parameters.parameters.client
        assert (client != '')
        client_ip = client[2:]
        client_name = 'wincdkbats-0' + client[0]
        return client_ip, client_name


class STAFHelper(object):
    try:
        handle = STAFHandle("BATsHandler")
    except STAFException, e:
        logger.info("Error registering with STAF, RC: %d" % e.rc)
        sys.exit(e.rc)

    def __init__(self):
        pass

    @staticmethod
    def run_command_async(ip, cmd):
        request_async = 'START SHELL COMMAND %s' % wrapData(cmd)
        try:
            result = STAFHelper.handle.submit(ip, "PROCESS", request_async)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s" % (cmd, result.rc, result.result))
            return result
        except Exception, e:
            logger.info('Err on staf run command async : %s' % e)
            return -1

    @staticmethod
    def run_command_sync(ip, cmd):
        request = 'START SHELL COMMAND %s WAIT RETURNSTDOUT RETURNSTDERR' % cmd
        try:
            logger.info(ip + " " + request)
            result = STAFHelper.handle.submit(ip, "PROCESS", request)
            # logger.info(result.resultObj)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s" % (cmd, result.rc, result.result))
            return result.rc
        except Exception, e:
            logger.info('Err on staf ping: %s' % e)
            return -1

    @staticmethod
    def run_command_sync2(ip, cmd, dir):
        request = 'START COMMAND %s WORKDIR "%s" WAIT RETURNSTDOUT RETURNSTDERR' % (cmd, dir)
        try:
            logger.info(ip + " " + request)
            result = STAFHelper.handle.submit(ip, "PROCESS", request)
            logger.info(result.resultObj)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s" % (cmd, result.rc, result.result))
            return result.rc
        except Exception, e:
            logger.info('Err on staf ping: %s' % e)
            return -1

    @staticmethod
    def run_command_sync3(ip, cmd):
        request = 'START SHELL COMMAND %s WAIT RETURNSTDOUT RETURNSTDERR' % wrapData(cmd)
        try:
            logger.info(ip + " " + request)
            result = STAFHelper.handle.submit(ip, "PROCESS", request)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s" % (cmd, result.rc, result.result))
            return result
        except Exception, e:
            logger.info('Err on staf ping: %s' % e)
            return None

    ''' Tricky method, just for reg query, force it run as 32bit. '''

    @staticmethod
    def run_command_sync4(ip, cmd):
        request = 'START SHELL COMMAND %s ENV \"PATH=C:\\Windows\\sysnative;{STAF/Env/PATH}\"  ' \
                  'RETURNSTDOUT STDERRTOSTDOUT WAIT' % wrapData(cmd)
        try:
            logger.info(ip + " " + request)
            result = STAFHelper.handle.submit(ip, "PROCESS", request)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s" % (cmd, result.rc, result.result))
            return result
        except Exception, e:
            logger.info('Err on staf ping: %s' % e)
            return None

    @staticmethod
    def submit(ip, service, request):
        try:
            # logger.info(service + " " + request)
            result = STAFHelper.handle.submit(ip, service, request)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s" % (request, result.rc, result.result))
            return result
        except Exception, e:
            logger.info('Err on staf request: %s' % e)
            return -1

    @staticmethod
    def copy_from_local_to_remote_temp(from_file, to_machine):
        """
            It will copy the file to c:\\temp of the remote machine

        :param from_file:
        :param to_file:
        :param to_machine:
        :return: true or false
        """
        ret = False
        '''will upload the installer file to the temp folder. Only support windows here.'''
        to_file = os.path.join('C:/temp', os.path.basename(from_file))
        copy_request = 'COPY FILE ' + from_file + ' TOFILE ' + to_file + ' TOMACHINE ' + to_machine
        try:
            result = STAFHelper.handle.submit('local', "FS", copy_request)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s"
                            % (copy_request, result.rc, result.result))
                time.sleep(5)
                return
            time.sleep(10)
            ret = True
        except Exception, e:
            logger.info('Err on staf ping: %s' % e)
        finally:
            return ret

    @staticmethod
    def copy_from_local_to_remote(from_file, to_file, to_machine, retry=1):
        """
            It will copy the file to the remote machine

        :param from_file:
        :param to_file:
        :param to_machine:
        :return: true or false
        """
        ret = False
        copy_request = 'COPY FILE ' + from_file + ' TOFILE ' + to_file + ' TOMACHINE ' + to_machine
        try:
            result = STAFHelper.handle.submit('local', "FS", copy_request)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s"
                            % (copy_request, result.rc, result.result))
                ''' Will retry one more to ensure the file be copied successfully. '''
                time.sleep(5)
                if retry != 2:
                    STAFHelper.copy_from_local_to_remote(from_file, to_file, to_machine, 2)
                return
            time.sleep(5)
            ret = True
        except Exception, e:
            logger.info('Err on staf copy from local to remote : %s' % e)
            time.sleep(5)
            if retry != 2:
                ''' Will retry one more to ensure the file be copied successfully. '''
                STAFHelper.copy_from_local_to_remote(from_file, to_file, to_machine, 2)
        finally:
            return ret

    @staticmethod
    def copy_from_remote_to_remote(from_file, to_file, remote_machine):
        """
            It's just a function of copy on the remote machine.

        :param from_file:
        :param to_file:
        :param remote_machine:
        :return: true or false
        """
        ret = False
        copy_request = 'COPY FILE ' + from_file + ' TOFILE ' + to_file + ' TOMACHINE ' + remote_machine
        try:
            result = STAFHelper.handle.submit(remote_machine, "FS", copy_request)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s"
                            % (copy_request, result.rc, result.result))
                return
            time.sleep(5)
            ret = True
        except Exception, e:
            logger.info('Err on staf copy to remote : %s' % e)
        finally:
            return ret

    @staticmethod
    def delete_file(machine, file_entry):
        ret = False
        delete_request = 'DELETE ENTRY ' + file_entry + ' file_entry'
        try:
            result = STAFHelper.handle.submit(machine, "FS", delete_request)
            if result.rc != 0:
                logger.info("Staf request fail, Request:%s RC: %d, Result: %s"
                            % (delete_request, result.rc, result.result))
                return
            ret = True
        except Exception, e:
            logger.info('Err on staf delete file: %s' % e)
        finally:
            return ret

    @staticmethod
    def fs_request(machine, fs_request):
        try:
            return STAFHelper.handle.submit(machine, "FS", fs_request)
        except Exception, e:
            logger.info('Err on staf FS: %s' % e)

    @staticmethod
    def staf_ping(ip):
        ret = False
        try:
            result = STAFHelper.handle.submit(ip, "ping", "ping")
            if result.rc != 0:
                # logger.info("Staf ping fail, RC: %d, Result: %s" % (result.rc, result.result))
                return
            if result.result != 'PONG':
                # logger.info("Staf ping fail, RC: %d, Result: %s" % (result.rc, result.result))
                return
            ret = True
        except Exception, e:
            logger.info('Err on staf ping: %s' % e)
        finally:
            return ret

    @staticmethod
    def staf_ping_timeout(ip, timeout=600, interval=20):
        ret = False
        elapsed_time = 0
        logger.info("STAF " + ip + " ping ping...")
        while elapsed_time < timeout:
            try:
                if STAFHelper.staf_ping(ip):
                    ret = True
                    break
            except:
                continue
            elapsed_time += interval
            time.sleep(interval)
        return ret

    @staticmethod
    def get_computer_name(ip):
        result = STAFHelper.submit(ip, 'var', 'resolve string {STAF/Env/COMPUTERNAME}')
        assert result.rc == 0, 'get computer name error.'
        return result.resultObj


def install(bats_env_parameters):
    """
            To install client.agent.broker at the same time.

            Each thread will handle one installation request, any failure will stop the thread. But the main thread
            will continue to run until get all the results from all the threads.

            Do not handle the RDSH installation since it depends on the broker. For the RDSH installation, refer the
            config function.

    """
    agent_queue = Queue()
    broker_queue = Queue()
    client_queue = Queue()

    if not bats_env_parameters.skip_agent:
        agent_runner = AgentRunner()
        # t1 = threading.Thread(target=agent_runner.install2, name="install agent",
        #                       args=[bats_env_parameters, agent_queue])
        t1 = Process(target=agent_runner.install2, name="[Process] install agent",
                     args=[bats_env_parameters, agent_queue])

    if not bats_env_parameters.skip_client:
        client_runner = ClientRunner(bats_env_parameters)
        t2 = Process(target=client_runner.install, name="[Process] install client",
                     args=[bats_env_parameters, client_queue])

    if not bats_env_parameters.skip_broker:
        broker_runner = BrokerRunner()
        t3 = Process(target=broker_runner.install2, name="[Process] install broker",
                     args=[bats_env_parameters, broker_queue])

    if not bats_env_parameters.skip_agent:
        t1.start()
    if not bats_env_parameters.skip_client:
        t2.start()
    if not bats_env_parameters.skip_broker:
        t3.start()

    if not bats_env_parameters.skip_agent:
        t1.join()
        if not agent_queue.get():
            logger.info("agent install fail, then to terminate")
            sys.exit(-1)
    if not bats_env_parameters.skip_client:
        t2.join()
        if not client_queue.get():
            logger.info("client install fail, then to terminate")
            sys.exit(-1)
    if not bats_env_parameters.skip_broker:
        t3.join()
        if not broker_queue.get():
            logger.info("broker install fail, then to terminate")
            sys.exit(-1)


def config(bats_env_parameters):
    rdsh_queue = Queue()
    agent_config_queue = Queue()

    rdsh_runner = RDSHRunner()
    agent_runner = AgentRunner()

    if not bats_env_parameters.skip_rdsh:
        t4 = Process(target=rdsh_runner.install2, name="[Process] install RDSH",
                     args=[bats_env_parameters, rdsh_queue])
    if not bats_env_parameters.skip_agent or bats_env_parameters.agent_config:
        t5 = Process(target=agent_runner.config, name="[Process] agent config",
                     args=[bats_env_parameters, agent_config_queue])

    if not bats_env_parameters.skip_rdsh:
        t4.start()
    if not bats_env_parameters.skip_agent or bats_env_parameters.agent_config:
        t5.start()

    if not bats_env_parameters.skip_rdsh:
        t4.join()
        if not rdsh_queue.get():
            logger.info("RDSH install fail, ignore")
    if not bats_env_parameters.skip_agent or bats_env_parameters.agent_config:
        t5.join()
        if not agent_config_queue.get():
            logger.info("agent config fail, then to terminate")
            sys.exit(-1)


def trigger_test_run(bats_env_parameters):
    client_runner = ClientRunner(bats_env_parameters)
    client_runner.run_tc()


def init_data():
    parameters = Parameters()
    bats_env_parameters = BATsEnvParameters(parameters)
    return bats_env_parameters


def tear_down():
    """
        will do some tear down work. (Enhance later.)
        1, delete all the downloaded files.
        2, will send out a summary mail to tell the execution result.
        3, Release the STAF handler

    """
    STAFHelper.handle.unregister()
    pass


def main():
    try:
        bats_env_parameters = init_data()
        install(bats_env_parameters)
        config(bats_env_parameters)
        if bats_env_parameters.run_tc:
            trigger_test_run(bats_env_parameters)
    finally:
        tear_down()


if __name__ == '__main__':
    main()
    pass
